package Java_First_Level_Lecture_8;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.ObjectInputFilter;
import java.util.*;

public class App11 {

    public static void main(String[] args) throws FileNotFoundException, ClassNotFoundException, InstantiationException, IllegalAccessException {

        Shirt myRedShirt = new Shirt("My shirt", 25,
                500, 'R');

        Clothing cloth = new Shirt("My green shirt", 30,
                237, 'G');

        Trourses myTrousers = new Trourses("My trousers", 50,
                'B');

        myRedShirt.setName("My shirt");

        System.out.println(myRedShirt + "\n" + cloth);

        System.out.println("~~~~~~~~~~~~~~~~~~~~~~");

        System.out.println(myRedShirt);
        myRedShirt.wash();
        System.out.println(myRedShirt);
        System.out.println(cloth);
        cloth.wash();
        System.out.println(cloth);

        System.out.println("~~~~~~~~~~~~~~~~~~~~~~~~~~");

        Laundry laundry = new Laundry();
        laundry.clean(myRedShirt, 40);
        laundry.clean(myTrousers, 40);

        //ArrayList<String> arrayListString = new ArrayList<>(); не очень хорошая реализация
        //List<String> listString = new LinkedList<>();//ArrayList<>(); // выполняется та же задача, но с разной реализацией

//        listString.add("1");
//        listString.add("2");
//        listString.add("3");
//        System.out.println("|--------------++++++++|");
//        for (String i : listString) {
//            System.out.print(i);
//        }

        // Чтение сканером из файла в лист
        // Для подстановки объекта реализующего интерфейс List<>, для конкретной задачи
        // К примеру для быстрого поиска ArrayList, для быстрой вставки LinkedList и т.д.
        List<String> stringList = (List<String>) Class.forName
                        (new Scanner
                                (new File("D:\\JavaProjects\\JavaCourseOracleFirstLevel\\src\\main\\java\\Java_First_Level_Lecture_8\\config"))
                                .nextLine())
                .newInstance();

        stringList.add("1");
        stringList.add("2");
        stringList.add("3");
        System.out.println("|--------------------------------------------------|");
        for (String strings : stringList) {
            System.out.print(strings);
        }

        System.out.println("|-------------------------------------|");
        Clothing[] clothing = {myRedShirt, myTrousers, cloth};
        Arrays.sort(clothing);
        System.out.println("|-------------------------|");
        for (Clothing c: clothing) {
            System.out.println(c);
        }

        System.out.println("|--------КОМПАРАТОР---------------|");
        //Сортировка класса к которому нет доступа
        //Arrays.sort(clothing, new ClothComparator());
        // с помощью лямбда-выражения
        //Arrays.sort(clothing, (o1, o2) -> o1.getName().compareTo(o2.getName()));
        // или так также с лямбда
        Arrays.sort(clothing, (o1, o2) -> {
            return o1.getSize() - o2.getSize();
        });
        for (Clothing c: clothing) {
            System.out.println(c);
        }


    }
    /*  Ссылочные переменные в Java разрешается инициализировать как объектами
     *   типа (класса) самой переменной, так и подтипа (подклсса)
     *
     *   В случае инициализации переменных объектами подтипа(подкласса),
     *   доступны лишь методы, объявленные в классе типа ссылочной переменной
     *
     *   Для получения доступа ко всем полям и методам объекта дочернего класса,
     *   необходимо использовать операцию приведения типа (нисходящее
     *   преобразование)
     *
     *                           ПОЛИМОРФИЗМ
     *   Полиморфизм - это возможность работать с несколькими типами так, как
     *   будто это один и тот же тип и в то же время поведение каждого типа
     *   будет уникальным в зависимости от его реализации. Тоесть один
     *   интерфейс - множество реализаций.
     *   Полиморфизм - один из четырёх основных принципов объектно-ориентированного
     *   программирования.
     *
     *   Подклассы могут определять уникальные характеристики а также наследовать
     *   и использовать функциональность родительского класса.
     *
     *   Полиморфический вызов - обращение производится через метод супер класса,
     *   но реальный объект - экземпляр подкласса
     *
     *                           ИНТЕРФЕЙСЫ
     *   Интерфейс - ссылочный тип данных, который может содержать лишь константы
     *   , сигнатуры методов и вложенные типы*(до Java SE 8); методы с
     *   реализацией (default и static).
     *
     *   Из интерфейсов нельзя создать объект (т.е. вызвать new). Они лишь
     *   могут быть либо реализованы в классах или расширены другими
     *   интерфейсами.
     *
     *   В Java любой класс может быть подклассом лишь одного класса, т.е.
     *   в общем случае в Java реализуется единичное наследование.
     *   При этом класс может реализовывать несколько интерфейсов.
     *   Таким образом использование интерфейсов - способ реализации
     *   множественного наследования.
     *
     *   Поэтому объект может "принадлежать" многим типам - типу своего класса
     *   , а также всех интерфейсов, которые он реализует.
     *
     *   По Java Code Convention название интерфейсов - деепричастия
     *   (суффикс - able)
     *
     *                           СОЗДАНИЕ ИНТЕРФЕЙСА
     *   Объявление интерфейса состоит из: модификатора доступа, ключевого
     *   слова "interface", имени интерфейса, списка родительских
     *   интерфейсов, разделённых запятыми и тела интерфейса.
     *
     *   Для интерфейсов, так же как и для классов применимы 2 модификатора
     *   доступа: "public" и package(default).
     *
     *   Интерфейс может наследовать другие интерфейсы, таким же способом
     *   как в случае классов (с помощью ключевого слова extends).
     *   Однако в отличае от классов интерфейс может наследовать любое
     *   количество других интерфейсов. При создании интерфейса через
     *   запятую указываются все родительские интерфейсы.
     *
     *   Тело интерфейса содержит методы, определяемые в нём.
     *
     *   Интерфейс может содержать объявление констант дополнительно к
     *   объявлению методов.*/

    /*Абстрактные классы vs интерфейсы
    *
    * Абстрактные классы могут содержать не абстрактные методы,
    * интерфейсы начиная с Java 8
    *
    * Абстрактные классы могут содержать не статические и не финальные
    * поля, интерфейсы - нет.
    *
    * Абстрактные классы могут реализовывать интерфейсы, если необходимо
    * реализовать не все абстрактные методы интерфейса
    *
    * |-----------------------------------------------------------------|
    * Когда что использовать
    *
    * Если абстрактный класс содержит только абстрактные методы,
    * он должен быть объявлен как интерфейс
    *
    * Абстрактные классы необходимо использовать в случае наследования
    * существующей реализации.
    *
    * Интерфейсы - единственный вариант, когда требуется множественное
    * наследование*/

}